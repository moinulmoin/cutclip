//
//  VideoInfo.swift
//  cutclip
//
//  Created by Moinul Moin on 6/27/25.
//

import Foundation

struct VideoInfo: Sendable, Codable {
    let id: String
    let title: String
    let description: String?
    let duration: TimeInterval
    let thumbnailURL: String?
    let channelName: String?
    let uploadDate: String?
    let viewCount: Int?
    let availableFormats: [VideoFormat]
    let availableCaptions: [CaptionTrack]
    let webpageURL: String
    
    var durationFormatted: String {
        let totalSeconds = Int(duration)
        let minutes = totalSeconds / 60
        let seconds = totalSeconds % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
    
    var hasHighDefinition: Bool {
        availableFormats.contains { format in
            guard let height = format.height else { return false }
            return height >= 720
        }
    }
    
    var hasCaptions: Bool {
        !availableCaptions.isEmpty
    }
    
    var qualityOptions: [String] {
        let qualities = availableFormats
            .compactMap { format -> String? in
                guard let height = format.height else { return nil }
                return "\(height)p"
            }
            .sorted { (first: String, second: String) -> Bool in
                let firstHeight = Int(first.dropLast()) ?? 0
                let secondHeight = Int(second.dropLast()) ?? 0
                return firstHeight > secondHeight
            }
        
        // Remove duplicates while preserving order
        var uniqueQualities: [String] = []
        for quality in qualities where !uniqueQualities.contains(quality) {
            uniqueQualities.append(quality)
        }
        
        // Add "Best" option if we have multiple formats
        if !uniqueQualities.isEmpty {
            uniqueQualities.insert("Best", at: 0)
        }
        
        return uniqueQualities
    }
    
    var truncatedDescription: String? {
        guard let description = description else { return nil }
        return description.count > 150 ? String(description.prefix(150)) + "..." : description
    }
}

struct VideoFormat: Sendable, Codable {
    let formatID: String
    let ext: String
    let height: Int?
    let width: Int?
    let fps: Double?
    let filesize: Int?
    let formatNote: String?
    let vcodec: String?
    let acodec: String?
    let quality: Int?
    
    var displayName: String {
        if let height = height {
            return "\(height)p"
        } else if let formatNote = formatNote {
            return formatNote
        } else {
            return formatID
        }
    }
    
    var filesizeFormatted: String? {
        guard let filesize = filesize else { return nil }
        
        let formatter = ByteCountFormatter()
        formatter.allowedUnits = [.useMB, .useGB]
        formatter.countStyle = .file
        return formatter.string(fromByteCount: Int64(filesize))
    }
    
    var isVideoFormat: Bool {
        vcodec != nil && vcodec != "none"
    }
    
    var isAudioFormat: Bool {
        acodec != nil && acodec != "none"
    }
}

struct CaptionTrack: Sendable, Codable {
    let language: String
    let languageCode: String
    let ext: String
    let url: String?
    let isAutoGenerated: Bool?
    
    var displayName: String {
        let autoSuffix = isAutoGenerated == true ? " (auto)" : ""
        return "\(language)\(autoSuffix)"
    }
}

// MARK: - yt-dlp JSON Response Models

struct YtDlpVideoInfo: Codable {
    let id: String
    let title: String
    let description: String?
    let duration: TimeInterval?
    let thumbnail: String?
    let uploader: String?
    let upload_date: String?
    let view_count: Int?
    let formats: [YtDlpFormat]?
    let subtitles: [String: [YtDlpSubtitle]]?
    let automatic_captions: [String: [YtDlpSubtitle]]?
    let webpage_url: String
    
    func toVideoInfo() -> VideoInfo {
        let availableFormats = formats?.compactMap { $0.toVideoFormat() } ?? []
        let captions = extractCaptions()
        
        return VideoInfo(
            id: id,
            title: title,
            description: description,
            duration: duration ?? 0,
            thumbnailURL: thumbnail,
            channelName: uploader,
            uploadDate: upload_date,
            viewCount: view_count,
            availableFormats: availableFormats,
            availableCaptions: captions,
            webpageURL: webpage_url
        )
    }
    
    private func extractCaptions() -> [CaptionTrack] {
        var captions: [CaptionTrack] = []
        
        // Add manual subtitles
        if let subtitles = subtitles {
            for (langCode, tracks) in subtitles {
                for track in tracks {
                    if let caption = track.toCaptionTrack(languageCode: langCode, isAuto: false) {
                        captions.append(caption)
                    }
                }
            }
        }
        
        // Add automatic captions
        if let autoSubtitles = automatic_captions {
            for (langCode, tracks) in autoSubtitles {
                for track in tracks {
                    if let caption = track.toCaptionTrack(languageCode: langCode, isAuto: true) {
                        captions.append(caption)
                    }
                }
            }
        }
        
        return captions
    }
}

struct YtDlpFormat: Codable {
    let format_id: String
    let ext: String
    let height: Int?
    let width: Int?
    let fps: Double?
    let filesize: Int?
    let format_note: String?
    let vcodec: String?
    let acodec: String?
    let quality: Int?
    
    func toVideoFormat() -> VideoFormat? {
        // Filter out audio-only formats and formats without proper video codec
        guard let vcodec = vcodec, vcodec != "none" else { return nil }
        
        return VideoFormat(
            formatID: format_id,
            ext: ext,
            height: height,
            width: width,
            fps: fps,
            filesize: filesize,
            formatNote: format_note,
            vcodec: vcodec,
            acodec: acodec,
            quality: quality
        )
    }
}

struct YtDlpSubtitle: Codable {
    let ext: String
    let url: String?
    let name: String?
    
    func toCaptionTrack(languageCode: String, isAuto: Bool) -> CaptionTrack? {
        let languageName = name ?? Locale.current.localizedString(forLanguageCode: languageCode) ?? languageCode
        
        return CaptionTrack(
            language: languageName,
            languageCode: languageCode,
            ext: ext,
            url: url,
            isAutoGenerated: isAuto
        )
    }
}